\documentclass[10pt]{report}
\usepackage{ifpdf}
\usepackage[utf8]{inputenc}
\usepackage[catalan]{babel}
\usepackage{makeidx}
\usepackage{lgrind}
\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

\usepackage{listings}
\lstset{frame=Ltb,
     framerule=0pt,
     aboveskip=0.5cm,
     framextopmargin=3pt,
     framexbottommargin=3pt,
     framexleftmargin=0.4cm,
     framesep=0pt,
     rulesep=.4pt,
     backgroundcolor=\color{gray97},
     rulesepcolor=\color{black},
     stringstyle=\ttfamily\color{red},
     showstringspaces = false,
     basicstyle=\small\ttfamily,
     commentstyle=\color{gray45},
     keywordstyle=\color{blue},
     numbers=left,
     numbersep=15pt,
     numberstyle=\tiny,
     numberfirstline = false,
     breaklines=true,
   }
 
% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
   {\lstset{#1}\pagebreak[0]}{\pagebreak[0]}
 
\lstdefinestyle{consola}
   {basicstyle=\scriptsize\bf\ttfamily,
    backgroundcolor=\color{gray75},
   }
 
\lstdefinestyle{Ada}
   {language=Ada,
   }

\title{Compiladors, segona entrega}
\author{José Ruiz Bravo, Biel Moyà Alcover, Álvaro Medina Ballester}
\date{16/01/2009}
\ifpdf
\pdfinfo {
    /Author (José Ruiz Bravo, Biel Moyà Alcover, Álvaro Medina Ballester)
    /Title (Compiladors, primera entrega)
    /Subject (Compiladors, primera entrega)
    /Keywords (compiladors, primera entrega, gramatica, lexic)
    /CreationDate (D:20081120195650)
}
\fi
\makeindex

\begin{document}
    \maketitle
    %\printindex
    \tableofcontents
    \index{Introducció@\textbf{Introducció}}
    \chapter{Introducció}
        La pràctica de l'assignatura \textit{1470 - Processadors del Llenguatge} consisteix en
        desenvolupar un compilador basat en el llenguatge Ada. Nosaltres hem decidit 
        utilitzar un subconjunt d'instruccions d'Ada traduïdes al català, per crear
        un llenguatge simple, senzill i facilment comprensible.
        \\
        \\
        En aquest document trobarem el codi font necessari per definir i utilitzar la
        taula de noms, el codi font del lèxic del llenguatge i l'especificació de la
        gramàtica del nostre llenguatge. Aquests documents es corresponen amb les primeres
        etapes del desenvolupament d'un compilador: l'anàlisi lèxica i l'anàlisi sintàctica\footnote{L'anàlisi sintàctica es completarà en posteriors versions de la pràctica.}.
    \newpage
    
    \index{Anàlisi Lèxica@\textbf{Anàlisi Lèxica}}
    \chapter{Analisi Lèxica}
        El nostre llenguatge el definirem a partir d'una gramàtica incontextual. Mitjançant l'eina \textit{aflex}, generam el codi necessari per representar el lèxic que hem definit. Els \textit{tokens} que composen l'apartat lèxic del compilador son els següents (fitxer \textit{compilemon.l}):
        \\
    
    % Codigo del analisis lexico
    \section{Descripció del lèxic: \textit{compilemon.l}}
    \begin{lstlisting}
-- Macros

lletra [A-Za-z]

digit [0-9]

separadors [\n\b\t\f]

caracter \'[^\'\n\t]\'



%%



-- Paraules clau

procediment {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_procediment;} 

inici       {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_inici;}

mentre      {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_mentre;}

per         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_per;}

entre       {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_entre;}

si          {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_si;}

sino        {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_sino;}

fi          {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_fi;}

fer         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_fer;}

const       {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_constant;}

tipus       {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_tipus;}

coleccio    {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_coleccio;}

registre    {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_registre;}

es          {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_es;}

llavors     {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_llavors;}

no          {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_no;}

entra       {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_entra;}

surt        {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_surt;}

nou         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_nou;}

nul         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_nul;}

de          {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_de;}

modul       {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_modul;}

rang        {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_rang;}

"||"        {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_or;}

"&&"        {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return pc_and;}


--SUBTIPUS

--Simbols 

":="        {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return s_assignacio;}

":"         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return s_dospunts;}

";"         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return s_final;}

","         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return s_coma;}

"("         {mt_atom(tok_begin_line, tok_begin_col, yylval);
            return s_parentesiobert;}

")"         {mt_atom(tok_begin_line, tok_begin_col, yylval);
            return s_parentesitancat;}

".."        {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return s_puntsrang;}
            
"."         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return s_puntrec;}


--Operadors

"<"         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return op_menor;}

"<="        {mt_atom(tok_begin_line, tok_begin_col, yylval);
            return op_menorigual;}

">="        {mt_atom(tok_begin_line, tok_begin_col, yylval);
            return op_majorigual;}

">"         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return op_major;}

"="         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return op_igual;}

"/="        {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return op_distint;}

"+"         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return op_suma;}

"-"         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return op_resta;}

"*"         {mt_atom(tok_begin_line, tok_begin_col, yylval);
            return op_multiplicacio;}

"/"         {mt_atom(tok_begin_line, tok_begin_col, yylval); 
            return op_divisio;}



--EXPRESSIONS REGULARS

--Digit

{digit}+     {mt_numero(tok_begin_line, tok_begin_col,yytext, yylval);
             return const;}
            
            
--Lletra

{caracter}   {mt_caracter(tok_begin_line, tok_begin_col,yytext, yylval); 
             return const;}


--String

\"[^\"\n\t]*\"  {mt_string(tok_begin_line, tok_begin_col, yytext, yylval);
                return const;}


--Identificador

{lletra}({digit}|{lletra})*    {mt_identificador(tok_begin_line, tok_begin_col,
                            yytext, yylval); return id;}



--Comentaris

"-""-"[^\n]*     {null;}


--Separadors

" "              {null;}

{separadors}*    {null;}


--Error

.            {return error;}



%%



with    decls.d_taula_de_noms,
        d_atribut,
        pk_usintactica_tokens;
        

use     decls.d_taula_de_noms,
        d_atribut,
        pk_usintactica_tokens;


package u_lexica is

    function YYLex return token;
    
end u_lexica;



package body u_lexica is

##


end u_lexica;
    \end{lstlisting}
    
    \newpage
    \section{Taula de noms}
        Hem definit una estructura de dades per emmagatzemar els identificadors i el strings. Aquesta estructura de dades es coneix com a \textit{taula de noms} i es similar a la que varem definir a classe.
        
    
    % Codigo de decls-d_taula_de_noms.ads
    \subsection{decls-d\_taula\_de\_noms.ads}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de declaracions de la taula de noms
-- ------------------------------------------------
--  Versio    :    0.1
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--    Especificacio de l'estructura necessaria
-- per el maneig de la taula de noms i dels metodes
-- per tractar-la.
--
-- ------------------------------------------------

with    decls.dgenerals,
        decls.d_hash; 
        
use     decls.dgenerals,
        decls.d_hash;


package decls.d_taula_de_noms is

    pragma pure;
    
    -- Excepcions
    E_Tids_Plena : exception;
    E_Tcar_Plena : exception;
    
    type taula_de_noms is limited private;
    
    procedure tbuida    (tn : out taula_de_noms);
    
    procedure posa_id   (tn : in out taula_de_noms;  
                        idn : out id_nom; 
                        nom : in string);
    
    procedure posa_str  (tn : in out taula_de_noms;
                        ids : out rang_tcar;
                          s : in string);
                        
    function cons_nom   (tn : in taula_de_noms; 
                        idn : in id_nom) return string;
    
    function cons_str   (tn : in taula_de_noms; 
                        ids : in rang_tcar) return string;
                                
    
    private
        
        type t_identificador is record 
                pos_tcar : rang_tcar;
                 seguent : id_nom;
            long_paraula : Natural;
        end record;
        
        type taula_identificadors is array (1 .. id_nom'Last) of t_identificador;
        
        type taula_caracters is array (1 .. rang_tcar'Last) of character;
        
        type taula_de_noms is record
              td : taula_dispersio;
             tid : taula_identificadors;
              tc : taula_caracters;
             nid : id_nom;
            ncar : rang_tcar;
        end record;
        
        -- Funcio de comparacio de dues paraules
        function par_iguals (par1, par2 : in string) return boolean;        
                    
            
end decls.d_taula_de_noms;         
    \end{lstlisting}
    
    \newpage
    \subsection{decls-d\_taula\_de\_noms.adb}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de declaracions de la taula de noms
-- ------------------------------------------------
--  Versio    :    0.2
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Implementacio dels procediments per al
--    tractament de la taula de noms:
--
--            - Buidat de la taula
--            - Insercio
--            - Insercio d'strings
--            - Consulta
--
-- ------------------------------------------------


package body decls.d_taula_de_noms is

    -- Donam els valors per defecte de cada camp, sempre 
    -- que un camp no sigui utilitzat valdra 0.
    procedure tbuida (tn : out taula_de_noms) is
    
    begin 
    
        for i in tn.td'range loop
            tn.td(i) := id_nul;
        end loop;
        
        tn.nid := 1;
        tn.ncar := 1;
        
        tn.tid(1).seguent := id_nul;
        
    end tbuida;
    
    
    
    function par_iguals (par1, par2 : in string) return boolean is
    
        it_p1 : integer;
        it_p2 : integer;
        
    begin
            
        if par1'Length = par2'Length then
            
            it_p1 := par1'First;
            it_p2 := par2'First;
                        
            while it_p1 < par2'Length and par2(it_p2) = par1(it_p1) loop
                it_p1 := it_p1 + 1;
                it_p2 := it_p2 + 1;
            end loop;
    
            if par1(it_p1) = par2(it_p2) then
                return true;
            end if;
            
        end if;
        
        return false;
    
    end par_iguals;
        


    procedure posa_id     (tn : in out taula_de_noms; 
                          idn : out id_nom; 
                          nom : in string) is
        
        -- Variable per el valor de la funcio de dispersio.
        p_tid : rang_dispersio;
        
        -- Indexos per recorrer la taula d'identificadors.
        idx : id_nom;
        idx_ant: id_nom; 
        
        -- Index per recorrer la taula de caracters.
        jdx : rang_tcar; 
        
        p : taula_identificadors renames tn.tid;
        
    begin
    
        p_tid := fdisp_tn(nom);
        
        -- Control d'errors
        if tn.nid = id_nul then
            raise E_Tids_Plena;
        end if;
        
        if (tn.ncar + nom'Length) > rang_tcar'Last then
            raise E_Tcar_Plena;
        end if;

        if tn.td(p_tid) = id_nul then
            tn.td(p_tid) := tn.nid;
        end if;
        
        idx := tn.td(p_tid);

        while idx /= id_nul and then not par_iguals(nom, cons_nom(tn, idx)) loop
             
             if p(idx).seguent = id_nul then
                idx_ant := idx;
             end if;
             
             idx := p(idx).seguent;     
            
        end loop;
        
        if idx = id_nul then

            idn := tn.nid;
            tn.tid(idx_ant).seguent := idn;
            
            -- Apuntam a la primera posicio buida de la taula de caracters
            tn.tid(idn).pos_tcar := tn.ncar; 
            tn.tid(idn).long_paraula := nom'Length;
            tn.tid(idn).seguent := id_nul;
            tn.nid := tn.nid + 1;
            -- Omplim la taula de caracters, desde la primera 
            -- posicio lliure 'ncar'.
            jdx := tn.ncar;
            
            for i in 1..nom'Length loop
                tn.tc(jdx) := nom(i);
                jdx := jdx + 1;
            end loop;
            
            jdx := jdx + 1;
            tn.tc(jdx) := '$';
            
            -- Apuntam a la primera posicio lliure de la taula 
            -- de caracters.
            tn.ncar := jdx + 1; 
            
        else
            idn := idx;
            
        end if;
        
    end posa_id;
    
    
    
    procedure posa_str     (tn : in out taula_de_noms; 
                           ids : out rang_tcar; 
                             s : in string) is
    
        -- Index per recorrer la taula de caracters.
        jdx : rang_tcar; 
        
    begin

        -- Excepcio per a controlar tc plena
        if (tn.ncar + s'Length) > rang_tcar'Last then
            raise E_Tcar_Plena;
        end if;
    
        -- Omplim la taula de caracters, desde la primera 
        -- posicio lliure 'ncar'.
        jdx := tn.ncar;
        ids := tn.ncar;
        
        for i in 1..s'Length loop
                
            tn.tc(jdx) := s(i);
            jdx := jdx + 1;
                
        end loop;
        
        tn.ncar := jdx + 1;
        tn.tc(jdx) := '$';

    
    end posa_str;
    
    
    
    function cons_nom (tn : in taula_de_noms; 
                      idn : in id_nom) return string is
        
    begin
    
        return string(tn.tc(tn.tid(idn).pos_tcar .. tn.tid(idn).pos_tcar+rang_tcar(tn.tid(idn).long_paraula)-1));
        
    end cons_nom;    
    
    
    
    function cons_str (tn : in taula_de_noms; 
                      ids : in rang_tcar) return string is
    
        idx : rang_tcar;
        
    begin
        
        idx := ids;
    
        while (tn.tc(idx) /= '$') loop
            idx := idx+1;
        end loop;
        
        return string(tn.tc(ids..idx-1));
        
    end cons_str;
                

end decls.d_taula_de_noms;
    \end{lstlisting}
    \newpage
    
    
    \section{Tokens i atributs}
    Hem definit el tipus token al paquet \textit{d\_token} i el tipus atribut (amb els procediments corresponents per crear atributs i la definició d'atribut) al paquet \textit{d\_atribut}. Una cop realitzada l'execució de l'eina \textbf{ayacc} sobre el fitxer \textit{pk\_usintactica.y}, ja no necessitarem el paquet \textit{d\_token.ads} i el substituirem per \textit{pk\_usintactica\_tokens}.
    \subsection{d\_token.ads}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de declaracions dels tokens
-- ------------------------------------------------
--  Versio    :    0.1
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Definicio del tipus token.
--
-- ------------------------------------------------

package d_token is

    type token is  (pc_procediment,
                    pc_inici,
                    pc_mentre,
                    pc_per,
                    pc_entre,
                    pc_si,
                    pc_sino,
                    pc_fi,
                    pc_fer,
                    pc_constant,
                    pc_tipus,
                    pc_coleccio,
                    pc_registre,
                    pc_es,
                    pc_llavors,
                    pc_no,
                    pc_opcio,
                    pc_casos,
                    pc_entra,
                    pc_surt,
                    pc_nou,
                    pc_nul,
                    pc_de,
                    pc_modul,
                    pc_inclou,
                    pc_usa,
                    pc_rang,
                    s_assignacio,
                    s_dospunts,
                    s_final,
                    s_coma,
                    s_parentesiobert,
                    s_parentesitancat,
                    s_puntsrang,
                    s_puntrec,
                    pc_or,
                    pc_and,
                    op_menor,
                    op_menorigual,
                    op_majorigual,
                    op_major,
                    op_igual,
                    op_distint,
                    op_suma,
                    op_resta,
                    op_multiplicacio,
                    op_divisio,
                    id,
                    const,
                    Error,
                    End_of_Input);
            
                    
end d_token;
    \end{lstlisting}
    \newpage
    
    \subsection{pk\_usintactica\_tokens}
    \begin{lstlisting}[style=Ada]
with  D_Atribut;
package Pk_Usintactica_Tokens is


    subtype yystype is d_atribut.atribut;

    YYLVal, YYVal : YYSType; 
    type Token is
        (End_Of_Input, Error, Pc_Procediment, Pc_Inici,
         Pc_Mentre, Pc_Per, Pc_Entre,
         Pc_Si, Pc_Sino, Pc_Fi,
         Pc_Fer, Pc_Constant, Pc_Tipus,
         Pc_Coleccio, Pc_Registre, Pc_Es,
         Pc_Llavors, Pc_No, Pc_Entra,
         Pc_Surt, Pc_Nou, Pc_Nul,
         Pc_De, Pc_Modul, Pc_Rang,
         Pc_Or, Pc_And, S_Assignacio,
         S_Dospunts, S_Final, S_Coma,
         S_Parentesiobert, S_Parentesitancat, S_Puntsrang,
         S_Puntrec, Op_Menor, Op_Menorigual,
         Op_Majorigual, Op_Major, Op_Igual,
         Op_Distint, Op_Suma, Op_Resta,
         Op_Multiplicacio, Op_Divisio, Id,
         Const, Menys_Unitari);

    Syntax_Error : exception;

end Pk_Usintactica_Tokens;
    \end{lstlisting}
    \newpage
    
    \subsection{d\_atribut.ads}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de procediments dels atributs
-- ------------------------------------------------
--  Versio    :    0.1
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        En aquest fitxer tenim implementats les 
--    assignacions de cada tipus de token al tipus
--    atribut que li correspon. Cal destacar 
--    l'utilitzacio de la taula de noms en els
--    casos d'identificadors i strings.
--
-- ------------------------------------------------

with    decls.dgenerals,
        decls.d_taula_de_noms;
        
use     decls.dgenerals,
        decls.d_taula_de_noms;


package d_atribut is


    type tipus_atribut is (atom,
                           a_ident,
                           a_lit_num,
                           a_lit_car,
                           a_lit_string);
                            
                            
    type atribut (t : tipus_atribut := atom) is record
        
        lin, col : natural;
        
        case t is
        
            when atom         => null;
            
            when a_ident      => idn : id_nom;
            
            when a_lit_num    => int : integer;
            
            when a_lit_car    => val : character;    
            
            when a_lit_string => ids : rang_tcar;
            
        end case;
                
    end record;
    
    
    procedure mt_atom        (l, c : in natural; a : out atribut);
    
    procedure mt_identificador  (l, c : in natural; 
                                    s : in string; 
                                    a : out atribut);
    
    procedure mt_string    (l, c : in natural; 
                               s : in string; 
                               a : out atribut);
    
    procedure mt_caracter    (l, c : in natural; 
                               car : in string; 
                                 a : out atribut);
    
    procedure mt_numero    (l, c : in natural; 
                               i : in string; 
                               a : out atribut);
        
    
end d_atribut;
    \end{lstlisting}
    \newpage
    
    \subsection{d\_atribut.adb}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de procediments dels atributs
-- ------------------------------------------------
--  Versio    :    0.1
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        En aquest fitxer tenim implementats les 
--    assignacions de cada tipus de token al tipus
--    atribut que li correspon. Cal destacar 
--    l'utilitzacio de la taula de noms en els
--    casos d'identificadors i strings.
--
-- ------------------------------------------------

with    u_lexica,
        decls.tn;

use     u_lexica,
        decls.tn;
        

package body d_atribut is    
    
    
    procedure mt_atom (l, c : in natural; a : out atribut) is
    
    begin
    
        a := (atom, l, c);
        
    end mt_atom;
    
    
    
    procedure mt_identificador (l, c : in natural; 
                                   s : in string; 
                                   a : out atribut) is
    
        id : id_nom := id_nul;
        
    begin
    
        posa_id(tn, id, s);
        a := (a_ident, l, c, id);
        
    end mt_identificador;
    
    
    
    procedure mt_string (l, c : in natural; 
                            s : in string; 
                            a : out atribut) is
    
        id : rang_tcar;
        
    begin
    
        posa_str(tn, id, s);
        a := (a_lit_string, l, c, id);
        
    end mt_string;
    
    

    procedure mt_caracter (l, c : in natural; 
                            car : in string; 
                              a : out atribut) is
    
    begin
    
       a := (a_lit_car, l, c, car(car'First+1));
       
    end mt_caracter;
        
        
        
    procedure mt_numero (l, c : in natural; 
                            i : in string; 
                            a : out atribut) is
    
    begin
    
        a := (a_lit_num, l, c, Integer'value(i));
        
    end mt_numero;
    

end d_atribut;
    \end{lstlisting}
    \newpage
    
    
    \chapter{Anàlisi Sintàctica}
    A l'Anàlisi Sintàctica podem trobar la gramàtica del nostre llenguatge i el fitxer \textit{pk\_usintactica.y}. Aquest fitxer és que utilitzam juntament amb l'eina \textbf{ayacc}.
    
    \section{Gramàtica}
    \begin{tabbing}
    \hspace*{2.0cm} \= \hspace*{0.5cm} \= \hspace*{0.8cm} \= \kill
        \textit{programa} \> $\rightarrow $ \> \textit{procediment} \\
        \\
        \textit{procediment} \> $ \rightarrow $ \> \textbf{PC\_PROCEDIMENT} \textit{encap} \textbf{PC\_ES} \\
        \> \> \> \textit{declaracions} \\
        \> \> \textbf{PC\_INICI} \\
        \> \> \> \textit{bloc} \\
        \> \> \textbf{PC\_FI} identificador; \\
        \\
        \textit{encap} \> $ \rightarrow $ \> identificador \textit{args} \\
        \\
        \textit{args} \> $\rightarrow$ \> (\textit{lparam}) \\
        \> $ \mid $ \> $ \lambda $ \\
        \\
        \textit{lparam} \> $\rightarrow$ \> \textit{lparam} ; \textit{param} \\
        \> $\mid$ \> \textit{param} \\
        \\
        \textit{param} \> $\rightarrow$ \> identificador : \textit{mode} identificador \\
        \\
        \textit{mode} \> $\rightarrow$ \> \textbf{PC\_ENTRA} \\
        \> $\mid$ \> \textbf{PC\_SURT} \\
        \> $\mid$ \> \textbf{PC\_ENTRA PC\_SURT} \\
        \\
        \textit{declaracions} \> $\rightarrow$ \> \textit{declaracions} \textit{declaracio} \\
        \> $\mid$ \> $\lambda$ \\
        \\
        \textit{declaracio} \> $\rightarrow$ \> \textit{dec\_var} \\
        \> $\mid$ \> \textit{dec\_constant} \\
        \> $\mid$ \> \textit{dec\_tipus} \\
        \> $\mid$ \> \textit{programa} \\
        \\
        
        \underline{-- Manual d'usuari variables} \\
        \textit{dec\_var} \> $\rightarrow$ \> \textit{lid} : identificador; \\
        \\
        \textit{lid} \> $\rightarrow$ \> \textit{lid}, identificador \\
        \> $\mid$ \> identificador \\
        \\
        
        \underline{-- Manual d'usuari constant} \\
        \textit{dec\_constant} \> $\rightarrow$ \> identificador : \textbf{PC\_CONSTANT} identificador := \textit{valor};  \\
        \\
        \textit{valor} \> $\rightarrow$ \> \textit{lit} \\
        \> $\mid$ \> $-$ \textit{lit} \\
        \\
        \textit{lit} \> $\rightarrow$ \> lit\_num \\
        \> $\mid$ \> lit\_car \\
        \> $\mid$ \> lit\_string \\
        \\
        
        \underline{-- Manual d'usuari tipus} \\
        \textit{dec\_tipus} \> $\rightarrow$ \> \textit{dec\_subrang}  \\
        \> $\mid$ \> \textit{dec\_registre} \\
        \> $\mid$ \> \textit{dec\_coleccio} \\
        \\
        \textit{dec\_subrang} \> $\rightarrow$ \> \textbf{PC\_TIPUS} identificador \textbf{PC\_ES PC\_NOU} identificador \textbf{PC\_RANG} \textit{valor} .. \textit{valor}; \\
        \\
        \textit{dec\_registre} \> $\rightarrow$ \> \textbf{PC\_TIPUS} identificador \textbf{PC\_ES PC\_REGISTRE} \\
        \> \> \> \textit{ldc} \\
        \> \> \textbf{PC\_FI PC\_REGISTRE}; \\
        \\
        \textit{ldc} \> $\rightarrow$ \> \textit{ldc dc} \\
        \> $\mid$ \> \textit{dc} \\
        \\
        \textit{dc} \> $\rightarrow$ \> identificador : identificador; \\
        \\
        
        \underline{-- Tipus colecció (\textit{array})} \\
        \textit{dec\_coleccio} \> $\rightarrow$ \> \textbf{PC\_TIPUS} identificador \textbf{PC\_ES PC\_COLECCIO} (\textit{lid}) \textbf{PC\_DE} identificador; \\
        \\
        \textit{lid} \> $\rightarrow$ \> \textit{lid}, identificador \\
        \> $\mid$ \> identificador \\
        \\
        
        
        \underline{-- Bloc d'instruccions} \\
        \textit{bloc} \> $\rightarrow$ \> \textit{bloc sent} \\
        \> $\mid$ \> \textit{sent} \\
        \\
        \textit{sent} \> $\rightarrow$ \> \textit{sassig} \\
        \> $\mid$ \> \textit{scond} \\
        \> $\mid$ \> \textit{srep} \\
        \> $\mid$ \> \textit{crida\_proc} \\
        \\
        
        \textit{sassig} \> $\rightarrow$ \> \textit{referencia} := \textit{expressio}; \\
        \\
        
        \textit{scond} \> $\rightarrow$ \> \textbf{PC\_SI} \textit{expressio} \textbf{PC\_LLAVORS} \\
        \> \> \>  \textit{bloc} \\
        \> \> \textbf{PC\_FI PC\_SI}; \\
        \> $\mid$ \> \textbf{PC\_SI} \textit{expressio} \textbf{PC\_LLAVORS} \\
        \> \> \> \textit{bloc} \\
        \> \> \textbf{PC\_SINO} \\
        \> \> \> \textit{bloc} \\
        \> \> \textbf{PC\_FI PC\_SI}; \\
        \\
        
        \textit{srep} \> $\rightarrow$ \> \textbf{PC\_MENTRE} \textit{expressio} \textbf{PC\_FER} \\
        \> \> \> \textit{bloc} \\
        \> \> \textbf{PC\_FI PC\_MENTRE}; \\
        \\
        
        \textit{crida\_proc} \> $\rightarrow$ \> \textit{referencia}; \\
        \\
        \textit{referencia} \> $\rightarrow$ \> identificador \\
        \> $\mid$ \> \textit{referencia}.identificador \\
        \> $\mid$ \> \textit{referencia} (\textit{prparam}) \\
        \\
        \textit{prparam} \> $\rightarrow$ \> \textit{expressio} \\
        \> $\mid$ \> \textit{expressio, prparam} \\
        \\
        
        \textit{expressio} \> $\rightarrow$ \> \textit{expressio} $ + $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ - $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ * $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ / $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} \textbf{PC\_MOD} \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ > $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ < $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ \geq $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ \leq $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ \neq $ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $ = $ \textit{expressio} \\
        \> $\mid$ \> $-$ \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} \&\& \textit{expressio} \\
        \> $\mid$ \> \textit{expressio} $\mid\mid$ \textit{expressio} \\
        \> $\mid$ \> \textbf{PC\_NO} \textit{expressio} \\
        \> $\mid$ \> (\textit{expressio}) \\
        \> $\mid$ \> \textit{referencia} \\
        \> $\mid$ \> \textit{lit} \\
    \end{tabbing}
    \newpage
    
    \section{Especificació: \textit{pk\_usintactica.y}}
    \begin{lstlisting}[style=Ada]
--Token
%token pc_procediment
%token pc_inici
%token pc_mentre
%token pc_per
%token pc_entre
%token pc_si
%token pc_sino
%token pc_fi
%token pc_fer
%token pc_constant
%token pc_tipus
%token pc_coleccio
%token pc_registre
%token pc_es
%token pc_llavors
%token pc_no
%token pc_entra
%token pc_surt
%token pc_nou
%token pc_nul
%token pc_de
%token pc_modul
%token pc_rang
%token pc_or
%token pc_and
%token s_assignacio
%token s_dospunts 
%token s_final
%token s_coma
%token s_parentesiobert
%token s_parentesitancat
%token s_puntsrang
%token s_puntrec
%token op_menor
%token op_menorigual
%token op_majorigual
%token op_major
%token op_igual
%token op_distint
%token op_suma
%token op_resta
%token op_multiplicacio
%token op_divisio
%token id
%token const 


--Precedencia
%left pc_or
%left pc_and
%nonassoc op_menor op_menorigual op_majorigual op_major op_igual op_distint
%left op_suma
%left op_resta
%left op_multiplicacio op_divisio pc_modul
%left pc_no
%left menys_unitari



--Definicio del tipus atribut
%with d_atribut
{
    subtype yystype is d_atribut.atribut;
}


%%


--Produccions de la gramatica del llenguatge
programa:
    M1 dec_procediment
  ;
  
M1: 
  ;

dec_procediment:
    pc_procediment encap pc_es
        declaracions
    pc_inici
        bloc
    pc_fi id s_final 
  ;

encap:
    id
  |
    pencap s_parentesitancat
  ;
  
pencap:
    pencap s_final param
  |
    id s_parentesiobert param
  ;
  
param:
    id s_dospunts mode id
  ;

mode:
    pc_entra
  |
    pc_surt
  |
    pc_entra pc_surt
  ;
  
declaracions:
    declaracions declaracio
  |
  ;
  

-- DECLARACIONS
declaracio:
    dec_var
  |
    dec_constant
  |
    dec_tipus
  |
    dec_procediment
  ;
  
dec_var:
    id c_decl_var
  ;
  
c_decl_var:
    s_dospunts id s_final
  |
    s_coma id c_decl_var
  ;

dec_constant:
    id s_dospunts pc_constant id s_assignacio const s_final
  ;
  

-- TIPUS
dec_tipus:
    decl_coleccio
  |
    decl_registre
  | 
    decl_subrang
  ;
  
  
-- TIPUS SUBRANG
decl_subrang:
    pc_tipus id pc_es pc_nou id pc_rang limit s_dospunts limit s_final
  ;
  
limit:
    const
  | 
    id
  ;
    
  
-- TIPUS REGISTRE
decl_registre:
    p_dregistre pc_fi pc_registre
  ;
  
p_dregistre: 
    p_dregistre id s_dospunts id s_final
  | 
    pc_tipus id pc_es pc_registre id s_dospunts id s_final
  ;
  

-- TIPUS COLECCIO
decl_coleccio:
    p_dcoleccio s_parentesitancat pc_de id s_final
  ;
  
p_dcoleccio:
    p_dcoleccio s_coma id
  |
    pc_tipus id pc_es pc_coleccio s_parentesiobert id
  ;

  
-- BLOC D'INSTRUCCIO
bloc:
    bloc sentencia
  | 
    sentencia
  ;
  
  
-- SENTENCIES D'INSTRUCCIONS
sentencia: 
    sassig
  |
    scond
  |
    srep
  | 
    crida_proc
  ;

-- Sentencia assignacio
sassig:
    referencia s_assignacio expressio s_final
  ;

-- Sentencia condicional
scond:
    pc_si expressio pc_llavors 
        bloc 
    pc_fi pc_si
  |
    pc_si expressio pc_llavors 
        bloc 
    pc_sino
        bloc
    pc_fi pc_si
  ;

-- Sentencia bucle
srep:
    pc_mentre expressio pc_fer
        bloc
    pc_fi pc_fer
  ;

-- Sentencia crida a procediment
crida_proc:
    referencia s_final
  ;

referencia:
    id
  |
    referencia s_puntrec id
  |
    pri s_parentesitancat
  ;
  
pri:
    referencia s_parentesiobert expressio
  |
    pri s_coma expressio
  ;
  
  
-- Expressions
expressio:
    expressio pc_or expressio
  |
    expressio pc_and expressio
  |
    pc_no expressio     %prec pc_no
  |
    expressio op_menor expressio
  |
    expressio op_menorigual expressio
  |
    expressio op_majorigual expressio
  |
    expressio op_major expressio
  |
    expressio op_igual expressio    
  |
    expressio op_distint expressio
  |
    expressio op_suma expressio
  |
    expressio op_resta expressio
  |
    expressio op_multiplicacio expressio
  |
    expressio op_divisio expressio
  |
    expressio pc_modul expressio
  |
    op_resta expressio   %prec menys_unitari
  |
    s_parentesiobert expressio s_parentesitancat
  |
    referencia
  |
    const
  ;
  
  
%%


package pk_usintactica is

    procedure yyparse;

end pk_usintactica;



with    pk_usintactica_tokens,
        pk_usintactica_shift_reduce,
        pk_usintactica_goto,
        compilemon_io,
        u_lexica,
        Ada.Text_IO;
        

use     pk_usintactica_tokens,
        pk_usintactica_shift_reduce,
        pk_usintactica_goto,
        compilemon_io,
        u_lexica,
        Ada,
        Ada.Text_IO;
        

package body pk_usintactica is

    procedure YYError (e : in string) is
    
    begin
        
        Put_Line(e);
        raise Syntax_Error;
    
    end YYError;
    
##

end pk_usintactica;
    \end{lstlisting}
    \newpage
    
    \chapter{Anàlisi Semàntica}
        En aquest capitol tenim la definició de les estructures de dades necesaries per l'anàlisi semàntic\footnote{En posteriors versions del document introduïrem les rutines semàntiques i la comprovació de tipus en aquest capItol.}.
        
    \section{Descripció}
    \subsection{decls-dtdesc.ads}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de declaracions del tipus descripcio
-- ------------------------------------------------
--  Versio    :    0.1
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Declaracions del tipus descripcio.
--
-- ------------------------------------------------


with    decls.dgenerals;

use     decls.dgenerals;


package decls.dtdesc is

    pragma pure;

    type tdescrip is (dnula,
                      dconst,
                      dvar,
                      dtipus,
                      dproc,
                      dcamp,
                      dargc);
                       
    type tipusdetipus is (tsbool,
                          tscar,
                          tsent,
                          tsrec,
                          tsarr,
                          tsnul);
    
    type descriptipus (tt: tipusdetipus := tsnul) is
        record
            ocup : despl;
            case tt is
                when tsbool | tscar | tsent => linf, lsup : valor;
                when tsarr                  => tcamp : id_nom;
                when tsrec | tsnul          => null;
            end case;
        end record;
        
    
    type descrip (td : tdescrip := dnula) is
        record
            case td is
                when dnula  => null;
                when dtipus => dt : descriptipus;
                when dvar   => tr : id_nom;
                               nv : num_var;
                when dproc  => np : num_proc;
                when dconst => tc : id_nom;
                               vc : valor;
                when dargc  => nvarg : num_var;
                                targ : id_nom;
                when dcamp  => tcamp : id_nom;
                                 dsp : rang_despl; 

            end case;
        end record;
    
        
end decls.dtdesc;
    \end{lstlisting}
    \newpage
    
    
    \section{Taula de Simbols}
    \subsection{decls-dtsimbols.ads}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Declaracions taula de simbols
-- ------------------------------------------------
--  Versio    :    0.1
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Declaracions dels procediments de la
--  taula de simbols.
--
-- ------------------------------------------------


with    decls.dtdesc,
        decls.dgenerals;
        
use     decls.dtdesc,
        decls.dgenerals;


package decls.dtsimbols is

    pragma pure;

    type tsimbols is limited private;
    type cursor_idx is private;
--    type cursor_arg is private;
    
    -- Operacions
    -- VERSIO 1: llenguatge simple sense estructura 
    -- de blocs estil Fortran.
    procedure tbuida (ts : out tsimbols);
    
    procedure posa (ts : in out tsimbols;
                    id : in id_nom;
                     d : in descrip;
                     e : out boolean);
                     
    function cons (ts : in tsimbols;
                   id : in id_nom) return descrip;
                    
                    
    -- VERSIO 2: Normal, llenguatge amb blocs estil Pascal.
    procedure entrabloc (ts : in out tsimbols);
    
    procedure surtbloc (ts : in out tsimbols);
    
    
    -- VERSIO 3: Blocs mes records.
    procedure posacamp (ts : in out tsimbols;
                       idr : in id_nom;
                       idc : in id_nom;
                         d : in descrip;
                         e : out boolean);
                        
    function conscamp (ts : in tsimbols;
                      idr : in id_nom;
                      idc : in id_nom) return descrip;
                       
                       
    -- VERSIO 4: Arrays.
    procedure posa_idx (ts : in out tsimbols;
                       ida : in id_nom;
                       idi : in id_nom;
                         e : out boolean);
                        
    function primer_idx (ts : in tsimbols;
                        ida : in id_nom) return cursor_idx;
                         
    function succ_idx (ts : in tsimbols;
                       ci : in cursor_idx) return cursor_idx;
                             
    function idx_valid (ci : in cursor_idx) return boolean;
    
    function cons_idx (ts : in tsimbols;
                       ci : cursor_idx) return id_nom;
                         
                         
    -- VERSIO 5: Procediments
--    procedure posa_arg (ts : in tsimbols;
--                       idp : in id_nom;
--                       ida : in id_nom;
--                         d : in descrip;
--                         e : out boolean);
                          
--    function primer_arg () return cursor_arg; --OMPLIR
--    
--    function succ_arg () return cursor_arg; --OMPLIR
--    
--    function arg_valid () return boolean; --OMPLIR
    
--    procedure cons_arg (ts : in tsimbols;
--                        ca : in cursor_arg;
--                       ida : out id_nom;
--                        dn : out descrip);
--                         
--    procedure actualitza (ts : in out tsimbols;
--                          id : in id_nom;
--                           d : in descrip);
    
    private
    
        type tipus_descrip is record
            np : nivell_prof;
             d : descrip;
             s : rang_despl;
        end record;
        
        type tipus_despl is record
            np : nivell_prof;
             d : descrip;
            id : id_nom;
             s : rang_despl; -- Afegit per tal d'implementar els records
        end record;
         
        type taula_blocs is array (1 .. nivell_prof'Last) of rang_despl;
        type taula_despl is array (1 .. rang_despl'Last) of tipus_despl;
        type taula_descrip is array (1 .. id_nom'Last) of tipus_descrip;
        
        type cursor_idx is new rang_despl;
            
        type tsimbols is record
            tdesc : taula_descrip;
           tdespl : taula_despl;
            tbloc : taula_blocs;
            nprof : nivell_prof;
        end record;
        

end decls.dtsimbols;
    \end{lstlisting}
    \newpage
    
    \subsection{decls-dtsimbols.adb}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Procediments taula de simbols
-- ------------------------------------------------
--  Versio    :    0.1
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Procediments per tractar la taula de
--      simbols:
--            - Taula buida
--            - Posa
--            - Consulta
--            - Entra bloc
--            - Surt bloc
--            - Posa camp
--            - Consulta camp
--            - Posa index
--            - Primer index
--            - Successor index
--            - Index valid?
--            - Consulta index
--            - Posa argument
--            - Primer argument
--            - Successor argument
--            - Argument valid?
--            - Consulta argument
--            - Actualitza
--
-- ------------------------------------------------

package body decls.dtsimbols is

    -- VERSIO 1: llenguatge simple sense estructura 
    -- de blocs estil Fortran.
    procedure tbuida (ts : out tsimbols) is
    
        descnula : descrip(dnula);
        
    begin
        
        ts.nprof := 1;
        ts.tbloc(ts.nprof) := 0;
        
        for i in 1 .. id_nom'Last loop
            ts.tdesc(i) := (0, descnula, -1);
        end loop;
    
    end tbuida;
    
    
    procedure posa (ts : in out tsimbols;
                    id : in id_nom;
                     d : in descrip;
                     e : out boolean) is
                      
        idespl : rang_despl;
    
    begin
    
        e := (ts.tdesc(id).np = ts.nprof);
        
        if not e then
            ts.tbloc(ts.nprof) := ts.tbloc(ts.nprof) + 1;
            idespl := ts.tbloc(ts.nprof);
            
            ts.tdespl(idespl) := (ts.tdesc(id).np, ts.tdesc(id).d, id, 0);
            ts.tdesc(id) := (ts.nprof, d, 0);
        end if;
    
    end posa;
    
    
    function cons (ts : in tsimbols;
                   id : in id_nom) return descrip is
                    
    begin
    
        return ts.tdesc(id).d;
    
    end cons;
    
    
    
    -- VERSIO 2: Normal, llenguatge amb blocs estil Pascal.
    procedure entrabloc (ts : in out tsimbols) is
    
    begin
    
        ts.nprof := ts.nprof + 1;
        ts.tbloc(ts.nprof) := ts.tbloc(ts.nprof - 1);
    
    end entrabloc;
    
    
    procedure surtbloc (ts : in out tsimbols) is
    
        idespl1 : rang_despl;
        idespl2 : rang_despl;
             id : id_nom;
        
    begin
    
        idespl1  := ts.tbloc(ts.nprof);
        ts.nprof := ts.nprof - 1;
        idespl2  := ts.tbloc(ts.nprof) + 1;
        
        for idespl in reverse idespl1 .. idespl2 loop
            if ts.tdespl(idespl).np >= 0 then
                id := ts.tdespl(idespl).id;
                ts.tdesc(id).d  := ts.tdespl(idespl).d;
                ts.tdesc(id).np := ts.tdespl(idespl).np;
                ts.tdesc(id).s  := ts.tdespl(idespl).s;
            end if;
        end loop;
    
    end surtbloc;
    
    
    
    -- VERSIO 3: Blocs mes records.
    procedure posacamp (ts : in out tsimbols;
                       idr : in id_nom;
                       idc : in id_nom;
                         d : in descrip;
                         e : out boolean) is
                          
            des : descrip;
             td : descriptipus;
              p : rang_despl;
        itdespl : rang_despl;
    
    begin
    
        des := ts.tdesc(idr).d;
        if des.td /= dtipus then e := TRUE; end if;
        
        td := des.dt;
        if td.tt /= tsrec then e := TRUE; end if;
        
        p := ts.tdesc(idr).s;
        while p /= 0 and then ts.tdespl(p).id /= idc loop
            p := ts.tdespl(p).s;
        end loop;
        
        e := (p /= 0);
        if not e then
            ts.tbloc(ts.nprof) := ts.tbloc(ts.nprof) + 1;
            itdespl := ts.tbloc(ts.nprof);
            ts.tdespl(itdespl) := (-1, d, idc, ts.tdesc(idr).s);
        end if;
        
    end posacamp;
    
    
    function conscamp (ts : in tsimbols;
                      idr : in id_nom;
                      idc : in id_nom) return descrip is
                       
             d : descrip;
            td : tdescrip;
             p : rang_despl;
      descnula : descrip(dnula);
                       
    begin
    
        d  := ts.tdesc(idr).d;
        td := d.td;
        
        p := ts.tdesc(idr).s;
        while p /= 0 and then ts.tdespl(p).id /= idc loop
            p := ts.tdespl(p).s;
        end loop;
        
        if p = 0 then
            return  descnula;
        else
            return ts.tdespl(p).d;
        end if;
    
    end conscamp;
    
    
    
    -- VERSIO 4: Arrays.
    procedure posa_idx (ts : in tsimbols;
                       ida : in id_nom;
                       idi : in id_nom;
                         e : out boolean) is
                        
             d : descrip;
            dt : descriptipus;
             p : rang_despl;
            pp : rang_despl;
        idespl : rang_despl;
                        
    begin
    
        d := ts.tdesc(ida).d;
        if d.td /= dtipus then e := TRUE; end if; -- Introduir control d'errors
        
        dt := d.dt;
        if dt.tt /= ts then e := TRUE; end if; -- Introduir control d'errors   
        
        p := ts.tdesc(ida).s;
        
        while p /= 0 loop
            pp := p;
            p := ts.tdespl(p).s;
        end loop;
        
        ts.tbloc(ts.nprof) := ts.tbloc(ts.nprof) + 1;
        idespl := ts.tbloc(ts.nprof);
        
        ts.tdespl(idespl) := (-1, dnula,idi, 0);
        
        if pp = 0 then
            ts.tdesc(ida).s := idespl;
        else
            ts.tdespl(pp).s := idespl;
        end if;        
    
    end posa_idx;
    
    
    function idx_valid (ci : in cursor_idx) 
                            return boolean is
    
    begin
    
        return (ci > 0);
    
    end idx_valid;
    
    
    function primer_idx (ts : in tsimbols;
                        ida : in id_nom) return cursor_idx is
    
    begin
    
        return cursor_idx(ts.tdesc(ida).s);
    
    end primer_idx;
    
    
    function succ_idx (ts : in tsimbols;
                       ci : in cursor_idx) return cursor_idx is
    
    begin
    
        if idx_valid(ci) then
            return cursor_idx(ts.tdespl(rang_despl(ci)).s);
        else 
            return 0;
        end if;
        
    end succ_idx;
    
    
    function cons_idx (ts : in tsimbols;
                       ci : in cursor_idx) return id_nom is
    
    begin
    
        return  ts.tdespl(rang_despl(ci)).id;
    
    end cons_idx;
    
    
end decls.dtsimbols;
    \end{lstlisting}
    \newpage
   
    
    
    \chapter{Declaracions i altres paquets}
        Per mantenir una organització del codi i dels paquets que anirem creant, hem definit un paquet anomenat \textit{decls} del qual penjen les declaracions. Com hem vist, la taula de noms penja d'aquest paquet, i a la vegada penjen els paquets \textit{d\_hash} i \textit{dgenerals} que son necessaris per la implementació de la taula de noms.
        \\
        
        Cal destacar que la funció de hash que empram per la taula de noms s'anomena Hash Quadràtic\footnote{http://es.wikipedia.org/wiki/Tabla\_hash\#Direccionamiento\_abierto} vista a l'assignatura \textit{1671 - Estructures de la Informació}.
    \newpage
    \index{Declaracions i altres paquets@\textbf{Declaracions i altres paquets}!decls.ads}
    \section{decls.ads}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de Declaracions
-- ------------------------------------------------
--  Versio  :   0.1
--  Autors  :   Jose Ruiz Bravo
--              Biel Moya Alcover
--              Alvaro Medina Ballester
-- ------------------------------------------------
--      Paquet de declaracions pare.
--
-- ------------------------------------------------

package decls is

    pragma pure;


end decls;
    \end{lstlisting}
    
    \newpage
    \section{decls-dgenerals.ads}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de declaracions generals
-- ------------------------------------------------
--  Versio    :    0.2
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Declaracions generals.
--
-- ------------------------------------------------

package decls.dgenerals is

    pragma pure;

    -- TAULA DE NOMS
    max_id : constant integer := 1000;
    type id_nom is new integer range 0 .. max_id;
    
    -- Valor nul per al tipus id_nom
    id_nul : constant id_nom := 0;
        
    -- La longitud es el nombre de paraules * la longitud de cadascuna
    longitut : constant integer := 40;
    type rang_tcar is new integer range 0 .. (longitut*max_id);
    
    -- Taula de dispersio:
    -- Tipus per la taula de dispersio de la taula de noms
    tam_dispersio : constant integer := 101;
    type rang_dispersio is new integer range -1 .. tam_dispersio;
    
    -- Valor nul per el rang dispersio
    dispersio_nul : constant rang_dispersio := -1;
    
    -- Declaracio de la taula de dispersio
    type taula_dispersio is array (rang_dispersio) of id_nom;
    
    
    -- TAULA DE SIMBOLS
    type despl is new integer;
    
    max_prof : constant integer := 20;
    type nivell_prof is new integer range 0 .. max_prof;
    nul_nprof : constant nivell_prof := 0;
    
    max_despl : constant integer := max_prof*max_id;
    type rang_despl is new integer range 0 .. max_despl;
    nul_despl : constant rang_despl := 0;
    
    -- Nombre de variables
    max_var : constant integer := 1000;
    type num_var is new integer range 0 .. max_var;
    
    -- Nombre de procediments
    max_proc : constant integer := 100;
    type num_proc is new integer range 0 .. max_proc;
    
    -- Tipus constant
    type valor is new integer range 0 .. integer'Last;


end decls.dgenerals;
    \end{lstlisting}
    \newpage
        

    \section{decls-d\_hash.ads}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de declaracions de les funcions hash
-- ------------------------------------------------
--  Versio    :    0.2
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Especificacio de les funcions de hash:
--            - Hash de Pearson per accedir a la 
--              taula de noms.
--
-- ------------------------------------------------

with    decls.dgenerals;

use     decls.dgenerals;


package decls.d_hash is

    pragma pure;

    function fdisp_tn (nom : in string) return rang_dispersio;
    
    
end decls.d_hash;
    \end{lstlisting}
    \newpage
    
    
    \section{decls-d\_hash.adb}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Paquet de procediments de les funcions hash
-- ------------------------------------------------
--  Versio    :    0.2
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Procediments de les funcions de hash:
--            - Hashing quadratic
--
-- ------------------------------------------------

package body decls.d_hash is

    function fdisp_tn (nom : in string) return rang_dispersio is
        
        a : array (nom'Range) of integer;
        r : array (1..2*nom'Last) of integer;
        
        k, c, m, n : integer;
        
        base : constant integer := character'pos(character'Last)+1;
        
    begin
        
        n := nom'Last;
        m := nom'Length;
    
        for i in 1..n loop
            a(i) := character'Pos(nom(i));
        end loop;
        
        for i in 1..2*n loop
            r(i) := 0;
        end loop;
        
        for i in 1..n loop
            c := 0; k := i - 1;
            for j in 1..n loop
                c := c + r(k+j) + a(i) + a(j);
                r(k+j) := c mod base;
                c := c/base;
            end loop;
            r(k+n+1) := r(k+n+1) + c;
        end loop;
        
        c := (r(n+1) * base + r(n)) mod (tam_dispersio);
        
        return rang_dispersio(c);
        
    end fdisp_tn;
    
    
end decls.d_hash;
    \end{lstlisting}
    \newpage
    
    
    \chapter{Programa principal}
        Al programa principal podem trobar un petit procediment de prova.
    \\
    
    \index{Programa principal@\textbf{Programa principal}!compilemon.adb}
    \section{compilemon.adb}
    \begin{lstlisting}[style=Ada]
-- ------------------------------------------------
--  Programa de prova
-- ------------------------------------------------
--  Versio    :    0.1
--  Autors    :    Jose Ruiz Bravo
--                 Biel Moya Alcover
--                 Alvaro Medina Ballester
-- ------------------------------------------------
--        Programa per comprovar les funcionalitats
--    del lexic i la taula de noms.
--
-- ------------------------------------------------

with    Ada.Text_IO,
        Ada.Command_Line,
        decls.d_taula_de_noms,
        decls.tn,
        decls.dgenerals,
        decls.dtsimbols,
        decls.dtdesc,
        pk_usintactica_tokens,
        compilemon_io,
        u_lexica,
        pk_usintactica;
        
use     Ada.Text_IO,
        Ada.Command_Line,
        decls.d_taula_de_noms,
        decls.tn,
        decls.dgenerals,
        decls.dtsimbols,
        decls.dtdesc,
        pk_usintactica_tokens,
        compilemon_io,
        u_lexica,
        pk_usintactica;
        

procedure compilemon is

begin

    tbuida(tn);
    
    Open_Input(Argument(1));
    yyparse;
--    Tk := Yylex;
    
--    while tk /= end_of_input loop
--        Put_Line(Token'Image(Tk));
--        Tk := Yylex;
--    end loop;
   
   Close_Input;
   
   exception
      when E_Tids_Plena => 
         Put_Line("ERROR: La taula d'identificadors es plena.");
         
      when E_Tcar_Plena =>
          Put_Line("ERROR: La taula de caracters es plena.");
          
      when Syntax_Error =>
        Put_Line("ERROR: Error a la linea "&yy_line_number'img&" i columna "&yy_begin_column'img);

end compilemon;
    \end{lstlisting}
    \newpage
    
    
    \section{Proves}
    Hem realitzat dos jocs de proves per comprovar el correcte funcionament de la nostra pràctica.
    \\
    \subsection{Prova 1: \textit{prova1.lem}}
    \begin{lstlisting}
procedimiento
procedimiento
procedimiento

"cadena"


      prova
proves
Es
ES
procedimiento
prova
prova
si
sino
    \end{lstlisting}
    \newpage
    
    \subsection{Prova 2: \textit{prova2.lem}}
    \begin{lstlisting}
procediment joan es
inici
    yyparse;
fi joan;
    \end{lstlisting}
\end{document}

